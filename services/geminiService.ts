import { GoogleGenAI, Type } from "@google/genai";
import { AspectRatio, ImageSize } from "../types";

// Helper to check for API Key selection (required for Pro Image model)
export const ensureApiKeySelected = async (): Promise<void> => {
  if (window.aistudio && window.aistudio.hasSelectedApiKey) {
    const hasKey = await window.aistudio.hasSelectedApiKey();
    if (!hasKey) {
       await window.aistudio.openSelectKey();
    }
  }
};

const getClient = () => {
  // Always create a new client to ensure we pick up any potentially selected keys from the environment
  return new GoogleGenAI({ apiKey: process.env.API_KEY });
};

/**
 * Texture Swap / Image Editing
 * Uses: gemini-2.5-flash-image (Nano Banana)
 */
export const swapTexture = async (
  targetImageBase64: string,
  referenceTextureBase64: string,
  prompt: string
): Promise<string> => {
  const ai = getClient();
  
  // Construct a prompt that guides the model to use the reference texture on the target image.
  const finalPrompt = `
    You are an expert image editor.
    Image 1 is the TARGET environment/object.
    Image 2 is the REFERENCE texture/material.
    
    User Request: ${prompt}
    
    Instruction: Edit Image 1 by applying the material/texture characteristics from Image 2 to the specified object in Image 1. 
    Maintain the lighting and perspective of Image 1 as much as possible, but replace the surface material.
    Return ONLY the edited image.
  `;

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    contents: {
      parts: [
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: targetImageBase64
          }
        },
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: referenceTextureBase64
          }
        },
        { text: finalPrompt }
      ]
    }
  });

  // Extract image from response
  for (const part of response.candidates?.[0]?.content?.parts || []) {
    if (part.inlineData && part.inlineData.data) {
      return `data:image/png;base64,${part.inlineData.data}`;
    }
  }
  
  throw new Error("No image generated by the model.");
};

/**
 * Image Generation
 * Uses: gemini-3-pro-image-preview (Nano Banana Pro)
 * Supports: Aspect Ratio, Image Size (1K, 2K, 4K)
 */
export const generateImage = async (
  prompt: string,
  aspectRatio: AspectRatio,
  size: ImageSize
): Promise<string> => {
  // Requirement: User MUST select their own API key for this model
  await ensureApiKeySelected();
  
  const ai = getClient();
  const response = await ai.models.generateContent({
    model: 'gemini-3-pro-image-preview',
    contents: {
      parts: [{ text: prompt }]
    },
    config: {
      imageConfig: {
        aspectRatio: aspectRatio,
        imageSize: size
      }
    }
  });

  for (const part of response.candidates?.[0]?.content?.parts || []) {
    if (part.inlineData && part.inlineData.data) {
      return `data:image/png;base64,${part.inlineData.data}`;
    }
  }

  throw new Error("No image generated. The model might have refused the prompt or failed.");
};

/**
 * Image Analysis
 * Uses: gemini-3-pro-preview
 * Supports: Thinking mode
 */
export const analyzeImage = async (
  imageBase64: string,
  prompt: string,
  useThinking: boolean
): Promise<string> => {
  const ai = getClient();
  
  const config: any = {};
  
  if (useThinking) {
    config.thinkingConfig = { thinkingBudget: 32768 }; // Max budget for pro
  }

  const response = await ai.models.generateContent({
    model: 'gemini-3-pro-preview',
    contents: {
      parts: [
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: imageBase64
          }
        },
        { text: prompt }
      ]
    },
    config: config
  });

  return response.text || "No analysis returned.";
};
